local function RayCast(Orgin, direction)
	
	local Args = RaycastParams.new()
	Args.FilterType = Enum.RaycastFilterType.Whitelist
	Args.FilterDescendantsInstances = {
		workspace.Map
	}
	Args.IgnoreWater = true
	
	local RayCast = workspace:Raycast(Orgin, direction, Args)
	
	if RayCast then
		return RayCast.Instance, RayCast.Position, RayCast.Normal, RayCast.Material
	else
		return false
	end
end

local function Test()
	print("Hello!")
end

local function Knockback(Args)
	local RS = game:GetService("ReplicatedStorage")
	local Effects = RS.Effects
	local Char, Direction, FlyingTime, Autostun = unpack(Args)
	local P = game.Players:GetPlayerFromCharacter(Char)
	local StartTime = tick()
	local InvOff = false
	
	local Check = Instance.new("BoolValue", Char)
	Check.Name = "Knockback"

	local C1Lock = Instance.new("BoolValue", Char)
	C1Lock.Name = "C1Lock"

	local End = false
	local EndWatch
	EndWatch = Char.ChildAdded:Connect(function(child)
		task.wait(0.01)
		if child.Name == "Knockback" then
			End = true
		end
	end)

	spawn(function()
		if Autostun == true then
			P.Backpack.GameStatus.Busy.Value = true
			local Stun = _G.TStun(Char, true)
		end
		
		if Char:FindFirstChild("Falling") then
			Char:FindFirstChild("Falling"):Destroy()
		end
		
		if Char:GetAttribute("Inv") == true then
			local InvEff = Instance.new("BoolValue")
			InvEff.Name = "InvEffOff"
			InvEff.Parent = Char
			game:GetService("Debris"):AddItem(InvEff, 0.6)
		end

		_G.Inv(true, Char, {
			true
		})
		

		local HRP = Char:WaitForChild("HumanoidRootPart")
		local Humanoid = Char:FindFirstChildOfClass("Humanoid")

		if typeof(FlyingTime) ~= "number" then
			FlyingTime = 0.5
		end

		if typeof(Direction) ~= "Vector3" then
			Direction = HRP.CFrame.LookVector * -80 + HRP.CFrame.UpVector * 10
		end
		
		local OldPos = HRP.Position

		spawn(function()
			if HRP:CanSetNetworkOwnership() then
				HRP:SetNetworkOwner(nil)
			end
		end)

		for i, v in pairs(HRP:GetChildren()) do
			if v:IsA("BodyMover") then
				v:Destroy()
			end
		end

		Humanoid.AutoRotate = false
		Humanoid.PlatformStand = true
		HRP.Anchored = false

		local Smoke = Effects.HitEffects.FlyingSmoke:Clone()
		Smoke.Parent = HRP
		
		
		local Remove
		Remove = Char.ChildRemoved:Connect(function(child)
			if child.Name == "Falling" or child.Name == "Knockback" then
				Smoke.Rate = 0
				task.wait(1)
				Smoke:Destroy()
				Remove:Disconnect()
			end
		end)

		local AirAnimations = RS.Animations.Knockback
		local Options, Options2 = AirAnimations.Flying:GetChildren(), AirAnimations.Sliding:GetChildren()
		local Knockback = Humanoid.Animator:LoadAnimation(Options[math.random(1, #Options)])
		local SlidingAnim = Humanoid.Animator:LoadAnimation(Options2[math.random(1, #Options2)])
		local GroundAnim = Humanoid.Animator:LoadAnimation(AirAnimations.OnTheGround)
		local GettingUp = Humanoid.Animator:LoadAnimation(AirAnimations.GettingUp)

		local Del = _G.GetWait(0.2, Char)
		local Speed = _G.GetWait(1, Char, true)

		task.spawn(function()
			for i, v in pairs(Humanoid.Animator:GetPlayingAnimationTracks()) do
				if v.Priority == Enum.AnimationPriority.Action then
					v:Stop()
				end
			end
			Knockback:Play(Del, 1, Speed)
		end)

		local BV = Instance.new("BodyVelocity")
		BV.MaxForce = Vector3.new(1, 1, 1) * math.huge
		print(Direction)
		BV.Velocity = Direction * _G.GetWait(1, Char, true)
		print(BV.P)
		BV.P = BV.P * _G.GetWait(1, Char, true)
		print(BV.P)
		BV.Name = "KnockBV"
		BV.Parent = HRP
		
		local VelocityEndPoint = HRP.CFrame:VectorToObjectSpace(BV.Velocity)
		local LookAtPoint = HRP.CFrame * CFrame.new(VelocityEndPoint)

		local Circles = Effects.HitEffects.AirLoops:Clone()
		Circles.Parent = workspace.Effects
		
		task.spawn(function()
			while Circles and Circles.Parent ~= nil do
				Circles.Position = HRP.Position
				Circles.AirLoops:Emit(Circles.AirLoops.EmitCount.Value)
				Circles.CFrame = CFrame.new(Circles.Position, LookAtPoint.Position)
				if Char:FindFirstChild("Falling") or End == true then
					Circles.AirLoops.Rate = 0
					task.wait(1)
					Circles:Destroy()
					break
				end
				task.wait(0.05)
			end
		end)

		RS.CharacterEvents:FireAllClients(Char, {"AirLaunch", LookAtPoint})
		
		local OldX1, OldY1, OldZ1 = BV.Velocity.X, BV.Velocity.Y, BV.Velocity.Z
		
		local VelChange = false
		
		repeat
			VelocityEndPoint = HRP.CFrame:VectorToObjectSpace(BV.Velocity)
			LookAtPoint = HRP.CFrame * CFrame.new(VelocityEndPoint)
			
			local OldRootY = HRP.Orientation.Y

			if not(BV or BV.Parent or End == true) then
				break
			end

			if VelocityEndPoint.Magnitude > 0 then
				HRP.CFrame = HRP.CFrame:lerp(CFrame.new(HRP.Position, LookAtPoint.Position) * CFrame.Angles(0, math.rad(180), 0), 0.075)
			end
			
			
			if tick() - StartTime >= FlyingTime * _G.GetWait(1, Char) then
				local Par = Instance.new("Part")
				Par.Name = "part"
				Par.CanCollide = false
				Par.Size = HRP.Size
				Par.Parent = workspace
				Par.Position = HRP.Position
				Par.Orientation = Vector3.new(0, HRP.Orientation.Y, 0)
				Par.CollisionGroupId = 1
				Par.Anchored = true
				
				if not Char:FindFirstChild("Falling") then
					local Flying = Instance.new("BoolValue", Char)
					Flying.Name = "Falling"
				end

				BV.Velocity = Vector3.new(BV.Velocity.X, math.clamp(BV.Velocity.Y - 2, -300, math.huge), BV.Velocity.Z) * _G.GetWait(1, Char)

				local GroundCheck, GroundCheckPos = RayCast(HRP.Position, Vector3.new(0, HRP.Size.Y * -1.5, 0))
				
				if GroundCheck ~= false and (BV and BV.Parent) and End == false then
					
					HRP.Anchored = true

					if Char:FindFirstChild("Falling") then
						Char:FindFirstChild("Falling"):Destroy()
					end

					if BV.Velocity.Y > -120 then
						RS.CharacterEvents:FireAllClients(Char, {
							"GroundHitNormal",
							GroundCheckPos
						})
					else
						RS.CharacterEvents:FireAllClients(Char, {
							"GroundHitHard",
							GroundCheckPos
						})
					end
					
					BV:Destroy()

					local EndOrient = CFrame.new(GroundCheckPos + Vector3.new(0, HRP.Size.Y * 1.5, 0)) * CFrame.Angles(0, math.rad(OldRootY), 0)
					
					if not HRP:FindFirstChild("KnockBV") then
						HRP.CFrame = EndOrient
					else
						End = true
					end

					local SlidePoint = EndOrient * CFrame.new(0, 0, (OldPos - HRP.Position).Magnitude / 2)

					OnGround = Instance.new("BoolValue", Char)
					OnGround.Name = "OnGround"

					SlidingAnim:Play(Del, 1, Speed)

					local SlideFX = Effects.HitEffects.Slide:Clone()
					SlideFX.Parent = workspace.Effects
					
					for i = 1, 75 do
						local GroundSlide, GroundPos = RayCast(HRP.Position, CFrame.new(HRP.Position, SlidePoint.Position).LookVector * 3)
						if GroundSlide ~= nil then
							if End == false then
								if not HRP:FindFirstChild("KnockBV") then
									--HRP.CFrame = HRP.CFrame:Lerp(SlidePoint, 0.05)
									SlideFX.CFrame = HRP.CFrame * CFrame.new(0, (HRP.Size.Y * -1.5) + (HRP.Size.Y / 2), 0)
								end
							else
								SlideFX:FindFirstChildOfClass("ParticleEmitter").Rate = 0
								delay(SlideFX:FindFirstChildOfClass("ParticleEmitter").Lifetime.Max, function()
									SlideFX:Destroy()
								end)
								break
							end
							task.wait()
						end
					end

					if End == true then
						break
					end

					GroundAnim:Play(Del, 1, Speed)

					SlideFX:FindFirstChildOfClass("ParticleEmitter").Rate = 0
					
					delay(SlideFX:FindFirstChildOfClass("ParticleEmitter").Lifetime.Max, function()
						SlideFX:Destroy()
					end)

					local UpdatedTime = tick()

					while true do
						if HRP:FindFirstChild("KnockBV") then
							End = true
							break
						end
						if tick() - UpdatedTime >= 1 then
							break
						end
						task.wait()
					end

					if End == true then
						break
					end

					Knockback:Stop(Del, 1, Speed)
					SlidingAnim:Stop(Del, 1, Speed)
					GettingUp:Play(Del, 1, _G.GetWait(1.8, Char, true))
					GroundAnim:Stop(Del, 1, Speed)
					
					_G.Inv(false, Char, {
						2
					})
					_G.Inv(true, Char, {
						false
					})
					
					InvOff = true
					
					task.spawn(function()
						for _, pl in pairs(game:GetService("Players"):GetPlayers()) do
							local VChar = pl.Character or pl.CharacterAdded:Wait()
							local VHRP = VChar:WaitForChild("HumanoidRootPart")
							if (VHRP.Position - HRP.Position).Magnitude <= 150 then
								RS.CharacterEvents:FireClient(pl, Char, {
									"iFrames"
								})
							end
						end
					end)

					local WallCheck, WallCheckPos = RayCast(HRP.Position, HRP.CFrame.LookVector * -10)
					local t
					local rot = HRP.Orientation.Y
					local BreakCheck = false
					
					if WallCheck ~= nil then
						if End == true then
							BreakCheck = true
						else
							t = HRP.CFrame * CFrame.new(0, 0, 5)
						end
					else
						if End == true then
							BreakCheck = true
						else
							--t = CFrame.new(WallCheckPos) * CFrame.Angles(0, math.rad(rot), 0)
						end
					end
					
					if BreakCheck == true then
						break
					end
					
					for i = 1, 75 do
						if End == true then
							BreakCheck = true
							break
						else
							--HRP.CFrame = HRP.CFrame:Lerp(t, 0.1)
						end
						task.wait()
					end
					
					if BreakCheck == true then
						break
					end
					
					--HRP.CFrame = t
					HRP.Anchored = false
					HRP.Velocity = Vector3.new(0, 0, 0)
					Humanoid.PlatformStand = false
					Humanoid.AutoRotate = true
					Humanoid.Jump = false
					
					Humanoid:ChangeState(Enum.HumanoidStateType.Running)
					
					if P and HRP:CanSetNetworkOwnership() then
						HRP:SetNetworkOwner(P)
					end
					
					EndWatch:Disconnect()
					
					break
				end
			end
			task.wait()
		until not BV or BV.Parent == nil or End == true
		
		if Autostun == true then
			if Char:FindFirstChild("Stunned") then
				Char:FindFirstChild("Stunned"):Destroy()
				P.Backpack.GameStatus.Busy.Value = false
			end
		end
		
		if InvOff == false then
			_G.Inv(true, Char, {
				false
			})
		end
		
		task.delay(_G.GetWait(0.5, Char), function()
			C1Lock:Destroy()
		end)
		
		EndWatch:Disconnect()
		Check:Destroy()
		if OnGround then
			OnGround:Destroy()
		end
	end)
end
